## Expression-parser
### Expression
* Разработать классы `Const`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide`
* Метод `evaluate` - вычисление выражения вместо каждой переменной `x` подставляется значение, переданное в качестве паратетра (также поддерживаются выражения с тремя переменными `x`, `y`, `z`)
* Метод `toString` - выдает запись выражения в полноскобочной форме, метод `equals` - проверяет на равенство два выражения
* Метод `toMiniString` - выдает запись выражения с минимальном число скобок

### Parser 
* Доработано предыдущее домашнее задание, так что бы выражение строилось по записи вида `x * (x - 2) * x + 1`
* В записи могут встречаться
	* бинарные операции: умножение `*`, деление `/`, сложение `+` и вычитание `-`;
	* унарный минус `-`;
	* переменные `x`, `y` и `z`;
	* целочисленные константы в десятичной системе счисления, помещающиеся в 32-битный знаковый целочисленный тип;
	* круглые скобки для явного обозначения приоритета операций;
	* произвольное число пробельных символов в любом месте, не влияющем на однозначность понимания формулы (например, между операцией и переменной, но не внутри констант). 
* Дополнительно реализованны бинарные операции `<<` (ShiftL), `>>` (ShiftR), `>>>` (ShiftA)

### Exceptions
* Добавлена обработка ошибок, в том числе:
	* ошибки разбора выражений
	* ошибки вычисления выражений
* Реализованы классы `CheckedAdd`, `CheckedSubtract`, `CheckedMultiply`, `CheckedDivide`, `CheckedNegate`, `CheckedPow` (операция `**` - `Pow` - возведение в степень), `CheckedLog` (операция `//` - `Log` - логарифм), `CheckedAbs` (операция `abs` - `Abs` - модель выражения)

### Generics
* В данной модификации требовалось к стандартным Add, Subtract, Multiply, Divide, Negate добавить операции Min, Max, Count, Abs
* Также добавить вычисление операций в различных типах(`mode`):
	* `i` – вычисления в int с проверкой на переполнение;
	* `d` – вычисления в double без проверки на переполнение;
	* `bi` – вычисления в BigInteger.
	* `u` – вычисления в int без проверки на переполнение;
	* `l` – вычисления в long без проверки на переполнение;
	* `t` – вычисления с усечением до кратных 10.
* Создать класс expression.generic.GenericTabulator, реализующий интерфейс expression.generic.Tabulator. Аргументы:
	* `mode` — режим работы
	* `expression` — вычисляемое выражение;
	* `x1`, `x2`; `y1`, `y2`; `z1`, `z2` — диапазоны изменения переменных (включительно).
Возвращаемое значение — таблица значений функции, где `R[i][j][k]` соответствует `x = x1 + i`, `y = y1 + j`, `z = z1 + k`. Если вычисление завершилось ошибкой, в соответствующей ячейке должен быть `null`.

## Games
### MNK-game
* Реализуйте ишру m,n,k (`k` в ряд на доске `m` на `n`) 
* Добавить обработку ошибкок ввода пользователея. В случае ошибочного хода пользователь имеет возможноть сделать другой ход

### Hex-game
* Добавлена поддержка ромбической доски для [игры Гекс](https://ru.wikipedia.org/wiki/Гекс)
* Игрок может вместо своего хода предложить ничью. Если второй игрок принимает предложение, то игра заканчивается. В противном случае, игра продолжается и игрок делает ход. Повторное предложение ничьей на том же ходу считается ошибкой.

##JavaScript
## Функциональные варыжения на JavaScript
* Реализовать функции `cnst`, `variable`, `add`, `subtracts`, `multiply`, `divide`, `negate` для вычиселений выражений с тремя переменными
* Дополнительно реализованы константы `pi`, `e`, а также `avg3` - среднее арифметическое 3х аргументов, `med5` - медиана 5 аргументов
* Реализовать функцию `parse`, которая разбирает выражения записаных в обратной польской записи

## Объектные выражение и обработка ошибок на JavaScript
* Разработать классы `Const`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide`, `Negate` для представления выражений с тремя переменными
* Функция `parse` выдает разобранное объектное выражение в обратной польской записи. `toString()` выдает запись выражения в обратной польской записи
* `diff` - возвращает выражение, представляющее производную от исходной переменной: `expr.diff("x")`
* Дополнительно реализована функция `Gauss` (`gauss`) - [функция Гаусса](https://ru.wikipedia.org/wiki/%D0%93%D0%B0%D1%83%D1%81%D1%81%D0%BE%D0%B2%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F) от 4х аргументов
* `parsePrefix(string), parsePostfix(string)` - разбирают выражения в полноскобочной префиксой и постфиксной формах соответсвенно, с человеко-читаемыми сообщениями об ошибке, если что-то пошло не так
* `prefix` - выдает выражение, которое ожидет `parsePrefix`, `postfix` - выдает выражение, которое ожидает на вход `parsePostfix`
* Дополнительно добавлены классы `Sumexp` (`sumexp`) - сумма экспонент, `Softmax`(`softmax`) - [softmax](https://ru.wikipedia.org/wiki/Softmax) первого арумента

##Clojure
### Линейная алгебра
* Разработайте функции для работы с объектами линейной алгебры, которые представляются следующим образом:
	* скаляры – числа
	* векторы – векторы чисел;
	* матрицы – векторы векторов чисел.
* Функции над векторами:
	* `v+`/`v-`/`v*`/`vd` – покоординатное сложение/вычитание/умножение/деление;
	* `scalar`/`vect` – скалярное/векторное произведение;
	* `v*s` – умножение на скаляр.
* Функции над матрицами:
	* `m+`/`m-`/`m*`/`md` – поэлементное сложение/вычитание/умножение/деление;
	* `m*s` – умножение на скаляр;
	* `m*v` – умножение на вектор;
	* `m*m` – матричное умножение;
	* `transpose` – транспонирование;
* Ко всем функциям должны быть указаны контракты.
* Назовем тензором многомерную прямоугольную таблицу чисел.
* Форма тензора – последовательность чисел `(s_1..n)=(s_1, s_2, …, s_n)`, где `n` – размерность тензора, а `s_i` – число элементов по `i`-ой оси. Например, форма тензора `[[[2 3 4] [5 6 7]]]`  равна `(1, 2, 3)`
* Тензор формы `(s_1..n)` может быть распространен (broadcast) до тензора формы `(u_1..m)`, если `(s_i..n)` является суффиксом `(u_1..m)`. Для этого, исходный тензор копируется по недостающим осям. Например, распространив тензор `[ [2] [3] ]` формы `(2, 1)` до формы `(3, 2, 1)` получим `[ [ [2] [3] ] [ [2] [3] ] [ [2] [3] ] ].
* Тензоры называются совместимыми, если один из них может быть распространен до формы другого. Например, тензоры формы `(3, 2, 1)` и `(2, 1)` совместимы. Числа совместимы с тензорами любой формы.
* Добавьте операции поэлементного сложения (`hb+`), вычитания (`hb-`), умножения (`hb*`) и деления (`hbd`) совместимых тензоров. Если формы тензоров не совпадают, то тензоры меньшей размерности должны быть предварительно распространены до тензоров большей размерности

### Функциональные выражения на CLojure
* Разработайте функции `constant`, `variable`, `add`, `subtract`, `multiply`, `divide` и `negate` для представления арифметических выражений.
* Выражение должно быть функцией, возвращающей значение выражения при подстановке переменных, заданных отображением. 
* Разработайте разборщик выражений, читающий выражения в стандартной для Clojure форме
должно быть эквивалентно expr.
* Функции `add`, `subtract`, `multiply` и `divide` должны принимать произвольное число аргументов. Разборщик так же должен допускать произвольное число аргументов для `+`, `-`, `*`, `/`.
* Дополнительно добавьте функции`sumexp` - сумма экспонент, `softmax` - [softmax](https://ru.wikipedia.org/wiki/Softmax) первого арумента

### Объектные выражения на Clojure
* Разработайте конструкторы `Constant`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide` и `Negate` для представления арифметических выражений.   
	* Функция `(evaluate expression vars)` должна производить вычисление выражения expression для значений переменных, заданных отображением vars.
	* Функция `(toString expression)` должна выдавать запись выражения в стандартной для Clojure форме.
	* Функция `(parseObject "expression")` должна разбирать выражения, записанные в стандартной для Clojure форме
	* Функция `(diff expression "variable")` должна возвращать выражение, представляющее производную исходного выражения по заданой перемененной.
* Конструкторы `Add`, `Subtract`, `Multiply` и `Divide` должны принимать произвольное число аргументов. Разборщик так же должен допускать произвольное число аргументов для `+`, `-`, `*`, `/`.
* * Дополнительно добавьте классы `Sumexp` (`sumexp`) - сумма экспонент, `Softmax`(`softmax`) - [softmax](https://ru.wikipedia.org/wiki/Softmax) первого арумента